#! /bin/zsh # shebang(シバン)指定のシェルで動かすことを宣言


# ----------------- #
# コマンドと標準入力・標準出力
# 標準入力・標準出力とは、コマンド用（プログラム・プロセス用）
# にあらかじめ確保されているデータの入出力経路（ストリーム）のことです。
# また、デフォルト設定では、標準入力は端末のキーボードに、
# 標準出力は端末の画面にそれぞれ接続されています。
# 標準出力や標準入力の接続先を変更することで、
# 他のデバイスから"入力"したりファイルに"出力"したりすることも可能です。

# パイプ | は、この接続先の変更を行うための手段の１つになります。
# 接続先の変更を行う手段には、他にもリダイレクトなどがあります
# | を利用することで、コマンドの標準出力を別のコマンドの標準入力に接続することが出来ます。
cat text.txt | hexdump
# 上記の例で言うと、
# cat コマンドの標準出力の接続先は hexdump の標準入力となります。

# ただ、パイプは、
# あくまでも「出力を渡す先がコマンドの標準入力」になります。
# | の右側で実行されるコマンドが標準入力を利用しない場合もあります。
# そういったコマンドは、標準入力からではなく「引数」として入力を受け取ることが多いです。
# そこで使えるのが、xargs
# xargs は、「標準入力からの入力」を引数に指定して
# 別のコマンドを実行するコマンドになります（ファイル等からでも入力できる）。
コマンド１ | xargs コマンド２
# xargs は、コマンド１の標準出力を、引数に、
# コマンド２を実行します。

# つまり、これらのコマンドは、入力経路（標準入力 or 引数）で使い分けましょう。

# Linuxコマンドがデータを受け取る入力経路（標準入力または引数）を判別する方法
# 標準入力を受け入れるコマンドならば、通常、パイプ(|)を使用して他のコマンドと組み合わせます。
# 代表的な、標準入力を入力経路としているLinuxコマンド
cat , grep , sort , wc , pbcopy

# ----------------- #



# 変数について
# 変数名 ハイフン、先頭に数字を使えない。
# 変数名=値 等号の前後にスペースを入れられない。
# /bin/shの範囲内で考えるシェルスクリプトについては、
# データ型はありません。すべてが文字列です。
# 変数にUNIXコマンドを代入することができます。
# ここまでのシェル変数とは異なり、特殊な役割を持つ変数がある。
# ・位置パラメータ -> 引数を処理するための変数
# ・環境変数 -> システム環境を設定するもの
# ----------------- #
# 変数の運用、代入
# 変数の展開は、$変数名でもできるけど、みんな${変数名}でやってるから、そっちでお願い。
fruit='apple' # 変数の宣言+初期化
$fruit="ringo" # $変数 の中に、値を代入することはできない。
echo $fruit # >> apple
fruit="banana" # 正しい値を変数に代入する方法。
echo ${fruit} # >> banana
# ----------------- #
# 出力されるデータ型について
# 文字列か？コマンドか？のどちらか。
fruit=apple # シェルスクリプトにデータ型という概念はないので、
animal=gorira # クォーテーションで囲う必要がない。
fruit=$animal # 変数の中身を代入したいなら、$をつけます。
echo $fruit # >> gorira
# ----------------- #
# 変数の定義、declareの使い方。
# シェル以外からも参照できる変数を「環境変数」と呼ぶ。
# 「export 変数名」でも設定可能
declare -x envVar # 指定した変数を環境変数にすることができます。
declare -r const # 読み取り専用の変数にします。
declare -i num # 変数をinteger用に定義する。
# declare -i が気になったのだ。
declare -i num=5
num="fake"
echo ${num} # >> 0 文字列を代入すると、中身が0になる。
num="10" 
echo ${num} # あ.."10"でも、数値の判定なんだね。
num="10  "
echo ${num} # スペースはいいんですか..
num="10という数字"
echo ${num} # あ..これはダメだった。
# ----------------- #
# 変数にコマンドを代入。
unix_ls=ls
unix_cd=cd
$unix_cd # 現在のターミナルがホームディレクトリに移動するわけではない。
$unix_ls # ホームディレクトリのlsコマンド実行結果が返ってきた。
# ----------------- #
# 指定のディレクトリでコマンドを実行
unix_ls=ls
dir=~/Documents/my_website
$unix_ls $dir # これで、指定のディレクトリでlsコマンドを実行できた。
# ----------------- #
# 位置パラメータ($1, $2など)を使うことで引数をとることができる。
# 第一引数は、$1, 第二引数は、$2, で受けられる。
# 位置パラメータ$0 = シェルスクリプトファイルそのものを出力します。
# シングルクォーテーションと、位置パラメーターは競合します。
echo "my name is "$1 $2 # zsh test.sh flan scarlet >> my name is flan scarlet
# ----------------- #
# ダブルクォーテーションだと変数を埋め込めます。
# ダブルクォーテーションで囲めば、スペースの入った文字列も代入できます。
echo '[ $1 = kishou ]'
echo "[ $1 = kishou ]"
# ----------------- #



# 条件分岐について
# シェルスクリプトのif文の条件式に当たるものは、コマンドです。
# 基本の書き方 -> if [<半角スペース>条件<半角スペース>];then
# 条件式の等号の前後にも半角スペースを忘れずに。
# ----------------- #
# 基本の構文
name=kishou

if [ $name = kishou ];then
    echo Correct name !
else
    echo Wrong Name !
fi
# ----------------- #
# []testコマンド以外のコマンドで記述
if ls;then # ifの直前のコマンドを実行できれば、trueを返す。
    echo lsコマンド
else
    echo something is diffrent
fi
# >> is_shellScript.txt      is_syntax.sh            test.sh
# >> lsコマンド

if ls-dammy;then
    echo lsコマンド
else
    echo something is different
fi
# >> test.sh:17: command not found: ls-dammy
# >> something is different
# ----------------- #



# 条件、演算子について。
# testコマンドについて
# testコマンドの振る舞いなどなど。
# []の中に条件式を書くが、[] <- は正しくはカッコではなく、
# [ <- testコマンドと呼ばれる、1つのコマンド。
# [ の最後の引数は ] となる。
# []以外にも、testというtestコマンドもあります。
Input="Yamashita"
test $Input = "Yamashita"
echo $? # まぁ、[]の方が読みやすいからtestはあんま使わんらしい。
# ----------------- #
# $?とは？
# $? は、特殊パラメータと呼ばれるものの１つ
# 特殊パラメータ = シェルによって自動的に値が決められる、特別な変数です。
# $? は、直前で実行したコマンドの終了ステータスの値を持ちます。
unix_backDir=".."
# if文の場合。
if cd $unix_backDir;then
    # if文のコマンド終了ステータスの値を持つ。
    echo $? # この場合は、trueなので、0が出力されます。
fi
# testコマンド[]の場合。
name="kishou" 
[ $name = "kishou" ]
echo $? # この場合も、trueなので、0が出力されます。
# ----------------- #
# 条件式で使える、演算子
# ファイル属性を調べる演算子もあります。
animal="kirin"
fruit=apple
num=1
[ $animal = "kirin" ] # >> 0 
[ -z "" ] # -z -> 空文字列ならtrue
[ -z $num ] # 空文字列なのでtrue
[ -n "" ] # -n は、なぜか、""の時しか、空文字列を判定しないので使えません。
[ $num = 2 ] # >> 1 
[ $num = 1 ] # >> 0
[ $num -eq 2 ] # >> 1 等価演算子と同じ。
[ $num -eq 1 ]  # >> 0
[ $num -gt 0 ] # >> 0 -gt -> >
[ $num -ge 1 ] # >> 0 -ge -> <
# ----------------- #
# ファイル属性を調べる演算子もありますよ。
[ -e is_shellScript.txt ] # >> 0 -e -> ファイルが存在するか判定します。
# ファイルの存在判定の、スコープはカレントディレクトリのみ。
# という大変狭いスコープなので、わざわざ、対象のディレクトリに移動します。
cd $unix_backDir/my_website
[ -e test.html ]
echo $? # >> 0 わざわざ対象のディレクトリまで移動した甲斐がありました。

cd $unix_backDir
[ -d "my_website" ] # こちらは、ディレクトリが存在するか判定します。
echo $? # >> 0 
# ----------------- #



# for文の使い方
# 文字列でfor文を回す。
for string in word01 word02 word03
do
    echo $string # >> word01 \n word02 \n word03
done
# ファイルでfor文を回す。
# ファイルを出力することもできます。
cd $unix_backDir/MyRuby

for rb_file in Lesson06*
do
    echo ${rb_file}
done
# 引数でfor文を回す。
# 引数を出力することもできます。
# in "$@" は、省略することもできます。
# $@ は、位置パラメータを全て参照するものです。
for string in "$@" 
do
    echo ${string}
done
# 数値でfor文を回す。
echo {1..10} # 1 ~10 までの数値を出力できます。
echo {${num}..10} # 変数の埋め込みにも対応してます。
num={1..10} # 変数への代入は対応してません。
for i in {1..3}
do
    echo ${i}
done

# ----------------- #
# 算術演算子について
num=$((1+1))
num01=3
echo $((num + num01)) # これ全部
echo $(($num + $num01)) # 処理結果同じなの
echo $((${num} + ${num01})) # 面白いよな。

# exprコマンドで算術演算を行えます。
# これは、演算結果で、for文をぶん回すことに成功しました。
for i in {1..`expr ${#array[@]} / 3`}
do
    echo $i
done

# ----------------- #



# 配列の定義
array=(1 2 3 4 5)
echo $array # >> 1 2 3 4 5
echo ${array} # >> 1 2 3 4 5
echo ${array[1]} # >> 1
# お決まりのfor文で配列で回します。
array=(1 2 3 4 5)
for num in ${array}
do
    echo ${num} # >> 1\n2\n3\n4\n5
done
# ----------------- #
# 勿論、配列の中身を変数に代入できます。
array=(a b c d)
roma=$array
uni_roma=${array[1]} # インデックスを取り出して代入もできます。
echo $roma
echo $uni_roma
# ----------------- #
# lsコマンドの実行結果を、配列の中身にします。
array=(`ls`)
echo ${array[2]}
# ----------------- #
# 配列の長さをカウントします。
echo ${#array[@]}
# ----------------- #



# while文について
# 基本的なwhile文の使い方
count=0
while [ 3 -gt $count ]
do
    count=$((++count))
    echo "${count}times"
done